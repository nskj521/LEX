cmake_minimum_required(VERSION 3.15)
project(lex VERSION 0.5.2 LANGUAGES C)
include(GNUInstallDirs)
set(CMAKE_C_STANDARD 11)

set(RESOURCE_DIR "${CMAKE_CURRENT_LIST_DIR}/resources")

set (SYNTAX_FILES
    ${RESOURCE_DIR}/syntax/c.json
    ${RESOURCE_DIR}/syntax/cpp.json
    ${RESOURCE_DIR}/syntax/go.json
    ${RESOURCE_DIR}/syntax/html.json
    ${RESOURCE_DIR}/syntax/java.json
    ${RESOURCE_DIR}/syntax/javascript.json
    ${RESOURCE_DIR}/syntax/json.json
    ${RESOURCE_DIR}/syntax/make.json
    ${RESOURCE_DIR}/syntax/php.json
    ${RESOURCE_DIR}/syntax/python.json
    ${RESOURCE_DIR}/syntax/ruby.json
    ${RESOURCE_DIR}/syntax/rust.json
    ${RESOURCE_DIR}/syntax/shell.json
    ${RESOURCE_DIR}/syntax/sql.json
    ${RESOURCE_DIR}/syntax/typescript.json
    ${RESOURCE_DIR}/syntax/zig.json
)

set (BUNDLER_SOURCE "${RESOURCE_DIR}/bundler.c")
add_executable(bundler ${BUNDLER_SOURCE})
set (BUNDLER_BIN $<TARGET_FILE:bundler>)
set (BUNDLED_FILE "${RESOURCE_DIR}/bundle.h")

add_custom_command(
    OUTPUT ${BUNDLED_FILE}
    COMMAND ${BUNDLER_BIN} ${BUNDLED_FILE} ${SYNTAX_FILES}
    DEPENDS bundler ${SYNTAX_FILES}
    WORKING_DIRECTORY ${CMAKE_CURRENT_LIST_DIR}
)

set (CORE_SOURCES
    src/action.c
    src/action.h
    src/buildnum.c
    src/buildnum.h
    src/config.c
    src/config.h
    src/common.h
    src/editor.c
    src/editor.h
    src/file_io.c
    src/file_io.h
    src/highlight.c
    src/highlight.h
    src/input.c
    src/input.h
    src/json.h
    src/lex.c
    src/opt.h
    src/os.h
    src/output.c
    src/output.h
    src/prompt.c
    src/prompt.h
    src/row.c
    src/row.h
    src/select.c
    src/select.h
    src/terminal.c
    src/terminal.h
    src/unicode.c
    src/unicode.h
    src/utils.c
    src/utils.h
)

if (WIN32)
  list(APPEND CORE_SOURCES
        src/os_win32.c
        src/os_win32.h
    )
else()
  list(APPEND CORE_SOURCES
        src/os_unix.c
        src/os_unix.h
    )
endif()

add_executable(${PROJECT_NAME} ${CORE_SOURCES} ${BUNDLED_FILE})

add_custom_target(file_toucher
    COMMAND ${CMAKE_COMMAND} -E touch_nocreate
            ${CMAKE_CURRENT_SOURCE_DIR}/src/buildnum.c
)

add_dependencies(${PROJECT_NAME} file_toucher)

target_compile_definitions(${PROJECT_NAME} PRIVATE
    EDITOR_NAME="${PROJECT_NAME}"
    EDITOR_VERSION="${CMAKE_PROJECT_VERSION}"
)

set(COMMON_HEADER "${CMAKE_SOURCE_DIR}/src/common.h")
if (MSVC)
  target_compile_options(${PROJECT_NAME} PRIVATE /W4 /wd4244 /wd4267 /wd4996 /FI "${COMMON_HEADER}")
else()
  target_compile_options(${PROJECT_NAME} PRIVATE -Wall -Wextra -pedantic -include "${COMMON_HEADER}")
endif()

install(TARGETS ${PROJECT_NAME})

# ==============================================================================
# Section to Create Automatic Uninstall Script
# ==============================================================================
# Define the uninstall script filename
set(UNINSTALL_SCRIPT "${CMAKE_CURRENT_BINARY_DIR}/uninstall.sh")

# Write the script content to the file
file(WRITE "${UNINSTALL_SCRIPT}"
"#!/bin/sh
# Uninstall script automatically generated by CMake
# Run with 'sudo ./uninstall.sh' from the build directory

if [ ! -f install_manifest.txt ]; then
    echo \"Error: 'install_manifest.txt' file not found.\"
    echo \"Make sure you are running this script from the 'build' directory.\"
    exit 1
fi

echo \"Removing installed files...\"
xargs rm -vf < install_manifest.txt

echo \"Uninstall complete.\"
"
)

# Make the script executable
file(CHMOD "${UNINSTALL_SCRIPT}"
     PERMISSIONS OWNER_READ OWNER_WRITE OWNER_EXECUTE
                 GROUP_READ GROUP_EXECUTE
                 WORLD_READ WORLD_EXECUTE
)

# Add an informative message during configuration
message(STATUS "Uninstall script has been created: ${UNINSTALL_SCRIPT}")
message(STATUS "To uninstall, run: cd build && sudo ./uninstall.sh")
